Title: Chapter 2 — Efficacy or efficiency
Date: 2017/01/03

# Efficacy or efficiency

<!-- ### intro + definitions -->
I feel like there may be confusion between attitudes of *efficacy* and *efficiency* in the software industry. The confusion exists on both ends: with the user and the maker. Efficacy is the power or capacity to produce a desired effect, effectivity, effectiveness. Efficiency is the ability to avoid wasting materials, energy, efforts, money, and time in doing. These two are closely related, but they are different visions for doing. I don't think this distinction is obvious in any visible way, from the users point of view at least. It is more related to an attitude and vision that the tool maker has of its user, her/his practice and way or reason for employing the tool. I think the misunderstanding of efficiency as efficacy has also come to further confuse our understanding of digital practices as abstracted crafts altogether.

<!-- ### easy intuitive fast — trade words -->
Today's commercial software makers are in constant competition. This is firstly due to the scarcity of commercial computing systems available, which in itself stems from the fact that there is essentially only one market of users to conquer. There are also multiple ways of delivering solutions in digital matters and often multiple implementations of said solutions. Boiling down competition benchmarks in this field comes down to two things: feature parity and ease; tentatively justifying in commercials how x solution or y product will bring more ease to a task. Software seems to be traded in terms of *Easy, intuitive, fast,* or even the ever simplistic *‘it just works’*. These qualifiers speak to the experience of use, rather than talking about the tools or tasks themselves. Speed, ease and good experience are what is sold to us, and this is what we are told we must expect.

<!-- ### speed -->
Speed in accomplishing a task is a parameter of the historic, economic and ideological developments reviewed in chapter 1. The desire to do something fast, because I have other things that I need to do (fast) seems to descend from a capitalist mindsets preaching that time is money. In many ways, without some aspects of industrial capitalism, I probably would not be able to voice these opinions about and though these mediums, so I'm not saying speed or capitalism are the direct destructor of computing (comprehension or conscience); however, the consequences of a capitalistic view of products, solutions and tools for virtual practices have affected specific dimensions of software tools, mainly in their attitudes and articulations, which are now geared towards answering problems and answering them efficiently. Efficiency effects all interface elements, from menu labels, windows, to launching processes right through to document saving and exporting dialogues.

One example of this is the preliminary need to set a document type or size when using canvas based software. The very first steps, before any manipulation or any virtualisation, requires the user to plan the output of the session. Having to chose a reference size, a colour profile, even sometimes a preset template before any practice can happen reveals a tool that requires the user to set parameters, to get them out of the way, narrowing the frame to get done with the task faster.

This choice would also have to be made early in the analog process, but virtualised practices recorded in files have the ability to be written and re-written at will. Probability is that the initial step of setting a scale in software comes to mimic the manual procedure, I plainly feel like this imitation sets an non-interesting boundary that goes against the nature of re-writable files, and computer systems. This prerequisite scale step, thinking of output before any input, shapes a linear process that has a set beginning and a set end. I believe this comes to limit how the tool is understood, or how it could speak of its boundaries. If physical scale was a requirement for the exporting process alone, maybe the making and using in the tool would be slightly less grounded, more flexible, truer to the possibilities that live memory systems offer. In turn, I think a change of this order could empower the user to have greater understanding and control of what digital virtualisation can bring to a practice. By this, I do not mean say that software tools should be less specific, less direct, or less applied to a field, nor should they avoid drawing upon the established practice that they virtualise, but changing the order of the established procedures would be telling of a virtualisation that augments a practice rather than only digitising it.

<!-- ### example of speed, timeline -->
Another example is a slight difference in saving procedures between two of my most regularly used canvas based software tools, Gimp and Inkscape. When my edits are done and I am ready to use my transformed file in other contexts, in Gimp, I must use a specific menu item labelled ‘Export as...’ that enables export to image file formats. The ‘File’ drop-down menu in Gimp also includes ‘Save’, ‘Save as...’ ‘Save a copy...’ before the export section. However, in Inkscape, the ‘Save as’ item is the one that I must use if I am to use the current file in other image formats.

![gimp-menu](../images/gimp-menu.png)

![inkscape-menu](../images/inkscape-menu.png)

There is logic to this difference, mainly due to the nature of the file formats and mediums that each program treats respectively, but the fact that Gimp asks to and uses the word ‘export’ delimits the space in which it was intended to act. The understanding of these labels is, in a large part, a matter of interpretation. In the context of interfaces, language and its interpretation are at the foundation. This work has a timeline, and if you're hovering over the export menu item, you're very close to the end of it. Keep in mind that typical export formats, jpeg, png, tiff, gif, are all formats that are accepted as initial input (through the import menu item, just a few lines down), so why this need to export? Meanwhile, Inkscape places static image formats inside it's general save menu, keeping *other use* formats and Inkscape augmented formats on a level playing field. The point of this example is not to compare the working of one tool versus an other, these are vastly different programs, respectively working in vastly different data and image types. The methods and working of the program descend from the different handling of bitmap and vector graphics. Instead the example is to display how, in some software conceptions, manipulation happens in the only intent of having an output, being an item in a chain. As with the paper-size example, this is a small interstice I'm pointing to, but one that is telling. The reality is that Gimp allows you save working documents, in its own .xcf extension, but the split here is in language, and the order of the usage process. The organisation of menu items and the actual words that are used to enact them are immensely important for the user and thus very important for the understanding of the intended spheres of use and action of the tool, by the makers. A productivist mindset has a harsh effect on any medium, leaving no space, or time for exploration of a tool for it's own sake. The tool that asks for 'export' does not speak of itself as an environment for manipulation and testing as much as it says that it is a set of procedures that are not valuable in contexts other than the ones they are intended in.

<!-- ### example of toolbars, tool-tips & narrative -->
A confusion between efficacy and efficiency is visible with some tool-tips: I hover over the multiple toolbars in my vector drawing application, for example, tool-tips appear with only ever short sets of descriptors around an imperative form verb: ‘Create rectangles and squares (F4)’, ‘Create and edit text (F8)’, ‘Snap bounding box’. Rather than describing what the tool can do, the language of the interface refers to what the tool is meant to be used for, it speaks to me in terms of what the tool was meant to be used for. A change of verb could suffice here, plain, indicative present tense speaking of related objects would give descriptor sentences instead of orders: ‘Creates rectangles and squares (F4)’, ‘Creates and edits text (F8)’, ‘Snaps bounding box’. Considering a small change in language could demonstrate the subtlety that exists in the difference between efficiency and efficacy. I believe this small change in language would make the difference between software being understood as a unidirectional, function-isolated tool or it being a place for thoughts to develop, by them being confronted with possibilities. The encouragement of trials and tests would alter perspectives and reorganise the ways in which the digital medium can be handled.

Aside from this tonal observation, the shortening of the legible language is plainly unnecessary. Is there any reason for these tool-tips not to be lengthened? The only explanation I can come up with for this imperative speech is a desire to optimise space. Vector drawing programs, as other drawing programs, can and do get crowded with toolbars and windows. But is this the reason for the short text? To be out of my way so that I can get my job done? Might this space optimisation be a relic of the CRT monitor age? I don't see why interfacing can't be more generous and verbose with the languages it uses. A little spray can icon tool is listed in a left vertical bar in inkscape. When hovered over, the tool-tip reads: ‘Spray objects by painting or sculpting’. Quite cryptic. I don't mean to be critical of this phrasing, it is exact and accurate, but a lot of pre-requisites are needed to understand such a sentence. This is not to say that it is the tool-tip's job, though this is slightly beside the point of this chapter and will be addressed in chapter 2. Specifically, what is wonder is, why the tool-tip text could not be the one that exists in the help menu. Then ‘Spray objects by painting or sculpting’ becomes ‘The Spray Tool is used to distribute copies of an object (or objects) much like an airbrush would paint drops’.

<!-- ### Ease -> experience -->
Next as a sign of efficiency, the idea of *ease* comes as a promise of consideration —and maybe premonition. Sales focus dictates that if something is easy, it is efficient. For something to be efficient, it must be made easy. *Easy* is employed upstream, it is said to anticipate and comes to respond to *complex*, which is the most feared label for a software maker. To tell a user that a software tool makes a task more accessible is one thing, to say that it makes a task easy drags in a long set of assumptions around what ease entails. I am not implying that ease is necessarily a negative attribute. There are plenty of reasons to celebrate greater ease within interfaces. There are plenty of reasons to encourage interface and software builders to think of easiness, the main one being potential larger accessiblity of a system. However, “easy” is a subjective term, and often ease of use results in automation and slick procedures that conceal the functionality of the software. I want to be able to understand how I use a tool.

An other way of saying this might be that I wish ease in interface came with the values of efficacy, but they only seem to be built through the lens of efficiency. It seems that the quest for easy interfacing tries to take on the inflection points caused by computer environments and smooth them out. I believe 'easy' to be a good goal for a software tool, so long as it remains reasonable, so long as it remains a wrapper, a collection of procedures, a multi-tool of sorts. *Easy* interface, in my opinion, has only been answered by what the industry is now calling *experience*.

![protoio](../images/protoio.png)
<figcaption>↗ proto.io, a user experience design app, says **Incredibly easy and fast** (accessed March 2017) </figcaption>

![patternry](../images/patternry.png)
<figcaption>↗ patternry, a front end design app, says **Designing consistent user experiences shouldn’t be that hard** (accessed March 2017) </figcaption>

Gathering the procedures and methods that serve a user in accomplishing a task in software under the term *experience* is a way of ironing out the specifics and the details, from the vending point of view. Meanwhile a flurry of new job titles have appeared to address the layering and renaming of procedures to interface to experience: Experience designers, User experience designers, User interface designers, Interaction designers, Product designers now all exist to address product communication in ways that are meant to keep the user enthused with what is happening on the screen. This creates a great distance once more between what the user does, and what is actually happening inside the computer. As many of the other ways modern software works, it seems to be aiming to disappear entirely, to remove any effort, therefor any thought. To be so fast that you don't see it work, or even think about the fact that it is doing work in the background. Seamless. We do need to remember that as much as the industry pushes the term experience, we are indeed here still talking about interface. (Lialina, 2014) Further, I believe that we also need to constantly remind that interface really is communication. Interface elements give access to functions, but in doing so, they isolate the procedure to an item in and of itself. I think the field of user experience is a result of software interface being a set of isolated procedures in which we forgot the start and the end points of. We only know the action, not the transformation. We know the verb, but not it's meaning. Interfaces of this sort add layers of opacity in order to achieve efficiency / efficiently.

![invision](../images/invision.png)
<figcaption>↗ invision, a prototyping tool, says **DESIGN BETTER. FASTER.** (accessed March 2017) </figcaption>

I see efficiency as the demand of a production focused work environment. Efficiency in interface is the demand of modern *technology* (a term I have been avoiding, to not widen the field of product and service too far away from software but also because technology as a stand alone term has no agency, it is a placeholder, a substitute for the industry to not have to deal with the specificity of computers → interfaces → technology). Modern software can't be talked about without mentioning solutionism funnelled through *technologies*. *“Technology is typically seen as a problem-solver, and well-designed technology *is supposed to follow an according aesthetic of efficiency*, ease and—ultimately—automation.”* (Morozov, 2013) It demands *better* methods for productions, an optimisation of resources —which is a view that entertains the idea that there is some sort of limit on supply, or that efficiency more often then not means trying to accomplish a task with less people, less resouces. I suppose that theoretically speaking, this taylorist optimisation towards seamlessness is without end, when one portion of the production chain is optimised, other areas then reveal themselves as less efficient. This leads to a vision of constant forwards motion, constant rethinking —which is another way of framing a second characteristic of capitalism; growth. The resulting attitude is the ideology of technologies and solutionism.

One final example of the confusion and how interpreting the language that results from it ends up hurting the user - software relationship is skeuomorphism. This subject had been addressed specifically here, but for word-count reasons it has been relocated to an [essay on Skeuomorphism on tangible.tools](http://tangible.tools/skeuomorphism-abstract-thought.html)

![sketch](../images/sketch.png)
<figcaption>↗ sketch a digital design app, [...]**gives you the power, flexibility and speed you always wanted**[...] and makes you **Work better, faster** (accessed March 2017) </figcaption>

![adobeexpriencedesignadobeXD](../images/adobeexperiencedesign.png)
<figcaption>↗ adobe experience design, is built [...]**with innovative tools that eliminate speedbumps**[...] and let one **Design at the speed of thought.** (accessed March 2017) </figcaption>

This set of elements tell me that indeed there is a confusion in between efficacy and efficiency. I have the desire for computer programs to be effective in that they let us explore the natures of computing, encoding and visualisations, but there seems only to be efficient solutions that tell us that we must not take concern with being effective. Most of the language and communication that surrounds software and applications sell a view of digital practice only being solutions to problems. The consequence of the way they are designed communicate that it is not our place to take concern with any of the substances that compose the digital and networked world, we are to use objects that answer singular problems in singular fashions. We may not take interest in the specificities of mediums. In this way the solutionist mindset cultivates a barrier between maker and user. For the former to sustain, it is best if the latter does not know too much about the characteristics of the procedures, matter or natures of digital mediums. Ultimately, efficacy in digital practice might not be attainable because of the confusion with efficiency. Vendors end up portraying computing only as a way of being more efficient but not as a practice that can question or a process that can better various fields.

The five screenshots above from Adobe XD, Sketch, InVision, Proto.io and Patternry show this portrayal, in it's commercial tone. I find myself to be very opposed to these procedures and solutions because I think computer culture is large and wild and needs not to be solutioned. I think we need to find other methods of working, in more consciousness, all of which will all necessitate a better understanding of the materials and the processes that happen on computers. We need interfaces and programs that reveal seams and boundaries, limiters, inputs and outputs so that we can build an understanding of some of the layers of abstraction that compose computers. We need programs and interfaces to help make the connections between the multiple tools they bring together and that show themselves as wrappers and containers of many entities, not stand alone magic boxes. Some examples of programs that show their inner composition or that exist to reveal their parts: [_playGnd](http://threejsplaygnd.brangerbriz.net/gui/), the XML editor in inkscape and the 3d page view in Firefox (details in chapter 3). I'm advocating for other ways because I find that the existing solutionism builds hierarchies, and orders users based on knowledge. Interface solutionism stops any curiosity and offuscates any visibility of the moving parts of a program. This experience and ease focused interface design produces a user that expects more from tools, while simultaneously stopping the potential learnin of digital literacy.

# References:

Fuller, Matthew, It looks like you're writing a letter: Microsoft Word, 5 Sept 2000 http://www.nettime.org/Lists-Archives/nettime-l-0009/msg00040.html

Lialina, Olia, Rich User Experience, UX and Desktopization of War, 7 November 2014 http://contemporary-home-computing.org/RUE/

Dobbins, Michael, Urban Design and People, 1st ed. “for the answer before the questions have been fully asked” (New York: Wiley, 2009), 182.

http://www.trademarkia.com/theres-an-app-for-that-77980556.html



<!-- This thread leads to the notions of productivity. The idea that methods can be employed to alter the speed of production. I think a lot of those trade words intutitive, easy, ‘just works’, are ways of talking productivity. The idea that a tool is trying to be efficient and get out of the way of production is interesting. I guess I can support it, if we were to think of a single utility hand tool, I can see how keeping it sharp and in good shape can aid my production, and the speed of accomplishing the task. But here is a gap. Software is very rarely only one tool. It's a collection of tools packaged together to practice multiple tasks of (possibly also multiple) (a) field[s]. A single hand tool speaks to us with it's materiality, with handles and indictions of how it is meant to be used. This is not to say that it must not be learned and mastered, but it is much more outspoken than the collections software tools that are summed up in icons, toolbars and tiny tiny tooltips.

In and of itself, productivity is not a bad thing, I'm simply saying that if it is the only language it employs to speak to the user, then it won't ever portray itself as a space for experimentation and leasure, it positions itself in a chain of events and not as a stand alone interesting object.

Productivity, it's place in software, how it continues proletarisation

Up to now in this chapter I have only been considering complex software, software for creation, software of abstracting craft. I stand by the idea that even utilitarian software has roots in processes that can be considered craft, however, the scope of software utilities is clearly narrower. By utility I mean calendar apps, contact management apps, note pads (simple text editors), calculators. I bring these up because they also clearly have a desire to get out of our ways, to get thigs written, events noted, etc. Still they need to distinguish themselves from one another, and they also want to be intuitive and usable. A difference here is the presumed knowledge of the user for utilitarian software is often more on par with reality than in the cases of complex software. These more simple programs are and have been, in my opinion, an other intersting case to look at the projection that software makers have of their users. -->

<!--
> *Technology is typically seen as a problem-solver, and well-designed technology **is supposed to follow an according aesthetic of efficiency**, ease and—ultimately—automation.*
<br><small>To Save Everything, Click Here — Evgeny Morozov, ch 9</small> -->

<!-- It's a film made by a someone who thinks you're a smart as he is. -->

<!-- What is the criterium for well-designed visual production software? Is that criterium in line with the established understanding of digital craft?
Is there a larger misunderstanding in software between efficiency and efficacy? -->

<!-- It's important to remember that I'm arguing for the view that all software has a root in a type of manual work, and that that work got made abstract, somehow. So these trade words are primarely problematic to me because they presume a certain amount of preexisting knowledge of the task at hand, but presumes even more knowledge of the workflow that is expected in the abstract. -->

<!-- An efficiency focus problematises the understanding of software as a place for practice. I attempt to detail the ways in which I believe these problems to be observable above. Meanwhile, my discourse has looked mainly at functional and interpretational dimentions of some software. Up to now I've been outlining how the ways of talking about software reveals some build methods -->
