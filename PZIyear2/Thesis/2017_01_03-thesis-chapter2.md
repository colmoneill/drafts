Title: Chapter 2 — Efficacy or efficiency
Date: 2017/01/03

# Efficacy or efficiency

projected structure:

* Intro to chapter + definition of two title notions.
* from capitalism to solutionism: optimisation, growth, problem solving, efficiency
* solutionism in software: examples of change in tone, tooltips,
* result of solutionist attitude in software affects the idea that the vendor has of it's users & the ability they have for abstract thought.

### intro + definitions
I feel like there may be confusion between attitudes of *efficacy* and *efficiency* in the software industry. The confusion exists on both end: the user and the maker / the vendor. This chapter looks at how the change that has happened in the conception of service tricked down to software, but also the conditions that makes it understood (or not) as a quality item, and how this change in service has come to influence what the user ends up seeking in her/his software tool. I think the misunderstanding of efficiency as efficacy has also come to further confuse our understandings of digital practices as crafts of abstraction and as practices all toghether. Efficacy is the power or capacity to produce a desired effect; effectiveness. Efficiency is the ability to avoid wasting materials, energy, efforts, money, and time in doing. I don't think this distinction is in any visible way obvious, from the users point of view at least. This has more to do with attitude and the vision that the tool maker has of it's user, her/his practice and way or reason for employing the tool.

### easy intuitive fast — trade words
Todays commercial software makers are in constant competition. This is firstly because of the few choices of commercial computing systems available, but also because there are multiple ways of bringing a solution to a problem when then matter is digital, and multiple implementations there of. I will boil down competition in this type of software to two things: feature parity and ease; justifying how x solution or y product will bring more ease to a task. Software is traded in terms of *Easy, intuitive, fast,* or even the ever aggresive *‘it just works’*. These qualifiers speak to the experience of use, rather than talking about the tool or task itself. Speed, ease and good experience, this is what is sold to us, and this is what we are told to expect.

### speed
Speed is an unfortunate parameter the historic, economic and ideologic developments that we reviewed in chapter 1. The desire to do something fast, because I have other things that I need to do (fast) descends from capitalist mindsets preaching that time is money. In many ways, without some aspects of industrial capitalism, I probably would not even be able to voice these opinions of and though these mediums, so I'm not saying it is a direct destructor of computing and service comprehention or conscience; however, the consequences of a capitalistic view on products, solutions and tools for virtual practices have affected specific dimentions of software tools, in their attitudes and speakings, which are now geared towards answering problems and answering them efficiently. Efficiency finally affects all interface elements, from menu labels to windows, from the launch of a process, right through to the way in which document saving and exporting dialogs are made. An example of this is the need to set a document type or size when using canvas based software. The very first steps, before any manipulation or any virtualisation, requires the user to plan the output of the session. Having to chose a reference size, a color profile, even a preset template before any practice can happen is telling of a tool that wants you to get all practical out of the way, for you to get done with the task faster.

### example of speed, timeline
A slight difference in saving procedures between two of my most regularly used canvas based software tools, Gimp and Inkscape tells about how each program imagines the user will deal with the outcomes of use. When my edits are done and I am ready to use my transformed file in other contexts, in Gimp, I must use a specific menu item labeled ‘Export as...’ that enables export to image file formats. The ‘File’ dropdown menu in Gimp also includes ‘Save’, ‘Save as...’ ‘Save a copy...’ before the export section. However, in Inkscape, the ‘Save as’ item is the one that I must use if I which to use the current file in other image formats.

![gimp-menu](../images/gimp-menu.png)

![inkscape-menu](../images/inkscape-menu.png)

There is logic to this difference, mainly due to the nature of the file formats and mediums that each program treats respectively, but the fact that Gimp asks to export delimits the space in which it was intended to act. This work has a timeline, and if you're hovering over the export menu item, you're very near the end of it. Keep in mind that typical export formats, jpeg, png, tiff, gif, are all formats that are accepted as initial input (through the import menu item, just a few lines down), so why this need to export? Meanwhile, Inkscape places static image formats inside it's general save menu, keeping *other use* formats and Inkscape augmented formats on a level playing field. The point of this example is not to compare the working of one tool versus an other, these are vastly different programs, respectively working in vastly different data and image types. the methods and working of the program of course descend from the different handelings of bitmap and vector graphics. Instead the example is to display how, in some software conceptions, manipulation happens in the only intent of having an output, being an item in a chain. The productivist mindest has a harsh effect on any exploration of a medium for it's own sake. The tool that asks for export does not speak of itself as an environment for manipulation and testing as much as it says that it is a set of procedures that are not valuable in other contexts than the ones they are intended in.

Example of multi window mode gimp

### object oriented speed
Non negligeable is another understanding that can be had of *rapidity* as in: processing *speed*. Traditional software (the kind that runs on your own machine, and your own local architecture, in opposition to off site cloud computing) has to deal with resource optimisation on a system level. Response to this management need leads to a way of building software called object oriented programming. In the background, programs get sectionned up into objects —a unique unchanging entity within the program complete with definitions of data and operations which it is permitted to carry out. The inner workings of the object, and interrelations between objects, are, as with most programs, hidden from the user. However, some inkling of their function can be gathered from what is visible at the interface and in use - in the division of the tools up into toolbars and in the various ways in which tools are shown to be able or not able to work on specific pieces of data. The use of toolbars is telling of this object orientation, and their groupings in similar funtions shows the set of scenarios that the user is allowed to leverage. (Fuller, 2000)

### example of toolbars, tooltips & narrative
A confusion between efficacy and efficiency is visible with some tooltips: I hover over the multiple toolbars in my vertor drawing application, for example, tooltips appear with only ever short sets of descriptors around an imperative form verb: ‘Create rectangles and squares (F4)’, ‘Create and edit text (F8)’, ‘Snap bounding box’. Instead of this language being a decription of what the tool can do, it speaks to me in terms of what the tool was meant to be used for. The simple turn of verb could suffice here, plain indicative present tense speaking of related objects would give descriptor sentences instead of orders: ‘Creates rectangles and squares (F4)’, ‘Creates and edits text (F8)’, ‘Snaps bounding box’.

Aside from this tonal obeservation, the incessant shortening of the legible language is beyond me. There is no reason for these tooltips not to be lengthened:

![](../images/project-proposal%20presentation/_3modes-of-address-language-change.png)

The only explanation I can come up with for this impertive speach is a desire to optimise space. Vector drawing programs, as other drawing programs, can and do get crouded with toolbars and windows. Is this the reason for the short text? To be out of my way so that I can get my job done? Might this space optimisation be a relic of the CRT monitor age? I think that the reason for short text might be that the software views itself only as a type of automation of a process helping to get a job done. As fast as possible.


### Ease -> experience
Next as a sign of efficiency, *ease* comes as a promise of consideration —and premotition. Easy is employed upstream, it is said to anticipate and comes to respond to *complex*, which is the most feared label for a software maker. If a product is thought of as complex, it is candidate for the next round of solutionist inovators to rethink the situation. And if a different management of the ins and outs of the problem (a reworking of the narrative) results in an *simpler* procedure for the user, well, the efficient minded user will be quick to move away. Ease also is the entry point for the last of the terms trade I've isolated: experience. Gathering the procedures and methods that serve a user in accomplishing a task in software under the term experience is an way of ironing out of the specifics and the details. As many of the other ways modern software works, it constantly seems to be aiming to dissapear entirely, to be effortless, to be so fast that you don't see it work, or even think about the fact that it is doing work in the background. Seamless. Everything gathered under *experience* needs to be understood and unpacked as *interface*. (Lialina, 2014)

I see efficiency as the demand of a production focused work environment. Efficiency in interface is the demand of modern *technology* —a term I have been avoiding, to not widen the field of product and service out of software, but modern software can't be talked about without mentionning solutionism funneled through *technologies*. It demands *better* methods for productions, an optimisation of resources —which is a view that entertains the idea that there is some sort of limit on supply. Theoretically speaking, this taylorist optimisation is endless, when one portion of the production chain is optimised, other areas then reveal themselves as less efficient. This leads to a vision of constant forwards motion, constant rethinking, which is another way of framing a second characteristic of capitalism; growth. The resulting attitude is the ideology of solutionism. The build process of software seems indeed to follow an idea that it comes to solve a problem. The problem may be that text writing and text editing is repetitive, lenghty and wasteful on paper. Or it may be that manual arangement of image and text on the same surface requires lots of steps, specific machines, to produce a layout for print. Either way, these manual procedures exist(ed) and somewhere along the line, somebody took account of them and started to build a solution to a problem. This again points to the term *solutionism* : a will to improve; a quest to ameliorate; an interpretation of issues as a puzzle to which there is a solution, rather than a problem to which there may be a response.

But how problems are composed matters every bit as much as how problems are resolved. (Dobbins, 2009)

> *Technology is typically seen as a problem-solver, and well-designed technology **is supposed to follow an according aesthetic of efficiency**, ease and—ultimately—automation.*
<br><small>To Save Everything, Click Here — Evgeny Morozov, ch 9</small>



This thread leads to the notions of productivity. The idea that methods can be employed to alter the speed of production. I think a lot of those trade words intutitive, easy, ‘just works’, are ways of talking productivity. The idea that a tool is trying to be efficient and get out of the way of production is interesting. I guess I can support it, if we were to think of a single utility hand tool, I can see how keeping it sharp and in good shape can aid my production, and the speed of accomplishing the task. But here is a gap. Software is very rarely only one tool. It's a collection of tools packaged together to practice multiple tasks of (possibly also mutiple) (a) field[s]. A single hand tool speaks to us with it's materiality, with handles and indictions of how it is meant to be used. This is not to say that it must not be learned and mastered, but it is much more outspoken than the collections software tools that are summed up in icons, toolbars and tiny tiny tooltips.

In and of itself, productivity is not a bad thing, I'm simply saying that if it is the only language it employs to speak to the user, then it won't ever portray itself as a space for experimentation and leasure, it positions itself in a chain of events and not as a stand alone interesting object.

Productivity, it's place in software, how it continues proletarisation

Up to now in this chapter I have only been considering complex software, software for creation, software of abstracting craft. I stand by the idea that even utilitarian software has roots in processes that can be considered craft, however, the scope of software utilities is clearly narrower. By utility I mean calendar apps, contact management apps, note pads (simple text editors), calculators. I bring these up because they also clearly have a desire to get out of our ways, to get thigs written, events noted, etc. Still they need to distinguish themselves from one another, and they also want to be intuitive and usable. A difference here is the presumed knowledge of the user for utilitarian software is often more on par with reality than in the cases of complex software. These more simple programs are and have been, in my opinion, an other intersting case to look at the projection that software makers have of their users.

Intuitive notions. Skeuomorphism

![](/images/Menu-Bar-Name-Removal-GIF.gif)

Efficiency vs efficacy is a difference of projection.

It's a film made by a someone who thinks you're a smart as he is.

<!-- What is the criterium for well-designed visual production software? Is that criterium in line with the established understanding of digital craft?
Is there a larger misunderstanding in software between efficiency and efficacy? -->

It's important to remember that I'm arguing for the view that all software has a root in a type of manual work, and that that work got made abstract, somehow. So these trade words are primarely problematic to me because they presume a certain amount of preexisting knowledge of the task at hand, but presumes even more knowledge of the workflow that is expected in the abstract.


# References:

Fuller, Matthew, It looks like you're writing a letter: Microsoft Word, 5 Sept 2000 http://www.nettime.org/Lists-Archives/nettime-l-0009/msg00040.html

Lialina, Olia, Rich User Experience, UX and Desktopization of War, 7 November 2014 http://contemporary-home-computing.org/RUE/

Dobbins, Michael, Urban Design and People, 1st ed. “for the answer before the questions have been fully asked” (New York: Wiley, 2009), 182.
