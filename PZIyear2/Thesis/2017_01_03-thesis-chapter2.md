Title: Chapter 2 — Efficacy or efficiency
Date: 2017/01/03

# Efficacy or efficiency

projected structure:

* Intro to chapter + definition of two title notions.
* from capitalism to solutionism: optimisation, growth, problem solving, efficiency
* solutionism in software: examples of change in tone, tooltips,
* result of solutionist attitude in software affects the idea that the vendor has of it's users & the ability they have for abstract thought.

I feel like there may be confusion between attitudes of *efficacy* and *efficiency* in the software industry. It is not so much confused by the ones who use software, but indeed by the ones who make it. I think it has also come to further confuse our understandings of digital practices as crafts of abstraction and as practices all toghether. Efficacy is the power or capacity to produce a desired effect; effectiveness. Efficiency is the ability to avoid wasting materials, energy, efforts, money, and time in doing. I don't think this distinction is in any visible way obvious, from the practitionners point of view at least. This has more to do with attitude and the vision that the tool maker has of it's user, her/his practice and the way and the reason the tool is employed.

Todays commercial software makers are in constant competition. This is because there are multiple ways of bringing a solution to a problem when then matter is digital, and multiple implementations of more or less similar solutions. Competition in this type of software can be boiled down to two things: feature parity and ease; justifying how x or y will bring more ease to a task. Software is traded in terms of *Easy, intuitive, fast,* or *‘it just works’*. These qualifiers speak to the experience of use, rather than talking about the tool or task itself, I suppose that was the job of the feature checkbox sheet. Speed, ease and good experience, this is what is sold to us.

Speed is an unfortunate parameter the historic economic and ideologic developments that we overflew in chapter 1. The desire to do something fast, because I have other things that I need to do (fast) descends from capitalist mindsets saying that time is money. In many ways, without some aspects of industrial capitalism, I probably would not even be able to voice these opinions of and though these mediums, so I'm not saying it is a direct destructor of computing comprehention or conscience; however, the consequences of a capitalistic view on products, solutions and tools for virtual practices have affected specific dimentions of software tools, in their attitudes and speakings, which are now geared towards answering said problem and answering it efficiently. Efficiency ends up affecting all interface elements, from menu labels to windows, from the launch of a process, right through to the order in which document saving and exporting dialogs are made. An example of this is the need to set a document type or size when using canvas based software. The very first steps, before any manipulation or any virtualisation, requires the user to plan the output of the session. Having to chose a reference size, a color profile, even a preset template before any practice can happen is telling of a tool that wants you to get all practical information out of the way, for you to get done with the task faster.

Example of multi window mode gimp

Example of gimp save being export, inkscape save being save as

Non negligeable is another understanding that can be had of *rapidity* as in: processing *speed*. Traditional software (the kind that runs on your own machine, and your own local architecture, in opposition to off site cloud computing) has to deal with resource optimisation on a system level. Response to this management need brings object oriented programming. Programs get sectionned up into objects —a unique unchanging entity within the program complete with definitions of data and operations which it is permitted to carry out. The inner workings of the object, and interrelations between objects, are, as with most programs, hidden from the user. However, some inkling of their function can be gathered from what is visible at the interface and in use - in the division of the tools up into toolbars and in the various ways in which tools are shown to be able or not able to work on specific pieces of data. (Fuller, 2000)

Then, *ease* comes as a promise of consideration —and premotition. Easy is employed upstream, it is said to anticipate and comes to respond to *complex*, which is the most feared label for a software maker. If a product is thought of as complex, it is candidate for the next solutionist inovator to rethink the situation. And if a different management of the ins and outs of the problem results in an simpler procedure for the user, well, the efficient minded user will be quick to move away. Ease also is the entry point for the last of the terms trade I've isolated: experience. Gathering the procedures and methods that serve a user in accomplishing a task in software under the term experience is an way of ironing out of the specifics and the details. As many of the other ways modern software works, it constantly seems to be aiming to dissapear entirely, to be effortless to be so fast that you don't see it work, or even think about the fact that it is doing work in the background. Everything gathered under *experience* needs to be understood and unpacked as *interface*. (Lialina, 2014)

Efficiency is the demand of a production focused mindset. Efficiency in interface is the demand of modern technology —a term I have been avoiding, to not widen the field of product and service out of software, but modern software can't be talked about without mentionning solutionism as technologies. It demands *better* methods for productions, an optimisation of resources —which is a view that entertains the idea that there is some sort of limit on supply. Theoretically speaking, optimisation is endless, when one portion of the production chain is optimised, other areas then reveal themselves as less efficient. This leads to constant progression, constant rethinking, which is another way of framing a second characteristic of capitalism; growth. The resulting attitude is the ideology of solutionism. The build process of software seems indeed to follow an idea that it comes to solve a problem. The problem may be that text writing and text editing is repetitive, lenghty and wasteful on paper. Or it may be that manual arangement of image and text on the same surface requires lots of steps, specific machines, and trial and error to produce a layout for print. Either way, these manual procedures exist(ed) and somewhere along the line, somebody took account of them and started to build a solution to a problem. This is an application of the term *solutionism* : a will to improve; a quest to ameliorate; an interpretation of issues as a puzzle to which there is a solution, rather than a problem to which there may be a response.

> *Technology is typically seen as a problem-solver, and well-designed technology **is supposed to follow an according aesthetic of efficiency**, ease and—ultimately—automation.*
<br><small>To Save Everything, Click Here — Evgeny Morozov, ch 9</small>



A confusion between efficacy and efficiency is visible with some tooltips: I hover over the multiple toolbars in my vertor drawing application, for example, tooltips appear with only ever short sets of descriptors around an imperative form verb: ‘Create rectangles and squares (F4)’, ‘Create and edit text (F8)’, ‘Snap bounding box’. Instead of this language being a decription of what the tool can do, it speaks to me in terms of what the tool was meant to be used for. The simple turn of verb could suffice here, plain indicative present tense speaking of related objects would give descriptor sentences instead of orders: ‘Creates rectangles and squares (F4)’, ‘Creates and edits text (F8)’, ‘Snaps bounding box’.

Aside from this tonal obeservation, the incessant shortening of the legible language is beyond me. There is no reason for these tooltips not to be lengthened:

![](../images/project-proposal%20presentation/_3modes-of-address-language-change.png)

The only explanation I can come up with for this impertive speach is a desire to optimise space. Vector drawing programs, as other drawing programs, can and do get crouded with toolbars and windows. Is this the reason for the short text? To be out of my way so that I can get my job done? The further I go into this reasoning the less I believe in it. It would be very hard to tell if software makers consider the positions of speech that congugation implies, rather I think that the reason for short text might be that the software views itself only as a type of automation of a process helping to get a job done. As fast as possible.

This thread leads to the notions of productivity. The idea that methods can be employed to alter the speed of production. I think a lot of those trade words intutitive, easy, ‘just works’, are ways of talking productivity. The idea that a tool is trying to be efficient and get out of the way of production is interesting. I guess I can support it, if we were to think of a single utility hand tool, I can see how keeping it sharp and in good shape can aid my production, and the speed of accomplishing the task. But here is a gap. Software is very rarely only one tool. It's a collection of tools packaged together to practice multiple tasks of (possibly also mutiple) (a) field[s]. A single hand tool speaks to us with it's materiality, with handles and indictions of how it is meant to be used. This is not to say that it must not be learned and mastered, but it is much more outspoken than the collections software tools that are summed up in icons, toolbars and tiny tiny tooltips.

In and of itself, productivity is not a bad thing, I'm simply saying that if it is the only language it employs to speak to the user, then it won't ever portray itself as a space for experimentation and leasure, it positions itself in a chain of events and not as a stand alone interesting object.

Productivity, it's place in software, how it continues proletarisation

Up to now in this chapter I have only been considering complex software, software for creation, software of abstracting craft. I stand by the idea that even utilitarian software has roots in processes that can be considered craft, however, the scope of software utilities is clearly narrower. By utility I mean calendar apps, contact management apps, note pads (simple text editors), calculators. I bring these up because they also clearly have a desire to get out of our ways, to get thigs written, events noted, etc. Still they need to distinguish themselves from one another, and they also want to be intuitive and usable. A difference here is the presumed knowledge of the user for utilitarian software is often more on par with reality than in the cases of complex software. These more simple programs are and have been, in my opinion, an other intersting case to look at the projection that software makers have of their users.

Intuitive notions. Skeuomorphism

![](/images/Menu-Bar-Name-Removal-GIF.gif)

Efficiency vs efficacy is a difference of projection.

It's a film made by a someone who thinks you're a smart as he is.

<!-- What is the criterium for well-designed visual production software? Is that criterium in line with the established understanding of digital craft?
Is there a larger misunderstanding in software between efficiency and efficacy? -->

It's important to remember that I'm arguing for the view that all software has a root in a type of manual work, and that that work got made abstract, somehow. So these trade words are primarely problematic to me because they presume a certain amount of preexisting knowledge of the task at hand, but presumes even more knowledge of the workflow that is expected in the abstract.


# References:

Fuller, Matthew, It looks like you're writing a letter: Microsoft Word, 5 Sept 2000 http://www.nettime.org/Lists-Archives/nettime-l-0009/msg00040.html

Lialina, Olia, Rich User Experience, UX and Desktopization of War, 7 November 2014 http://contemporary-home-computing.org/RUE/
